% sprcs.tex
%	Last update: 2022/03/23 F.Kanehori
\newpage
\section{sprcs.cpp}
\label{sec:sprcs}

\subsection{関数一覧(このソースの中にあるものだけ)}
\begin{narrow}[\WID]
	\begin{narrow}[20pt]\begin{minipage}{.8\textwidth}
	\dirtree{%
		.1 {\hspace{-10mm}top()}.
		.2 FindNodeR() \RECURSE.
		.2 get\_node\_info().
		.3 analyze\_syntax().
		.4 analyze\_function().
		.5 analyze\_init\_funcargs().
		.6 analyze\_count\_funcargs().
		.5 get\_node\_info() \DESCRIBED.
		.4 analyze\_array().
		.5 analyze\_get\_id().
		.4 analyze\_qualifier().
		.4 analyze\_vector().
		.5 analyze\_get\_id() \DESCRIBED.
		.4 analyze\_get\_id().
		.3 analyze\_type\_hook().
		.4 analyze\_type\_hook\_1().
		.3 analyze\_name\_hook().
		.4 replace\_partial\_string().
		.3 set\_type\_info().
		.4 analyze\_enum().
		.4 analyze\_vector().
		.5 analyze\_get\_id() \DESCRIBED.
		.4 analyze\_qualifier() \DESCRIBED.
		.4 strip\_paren().
		.4 analyze\_cpp\_type\_repr().
		.4 analyze\_marshaltype().
		.4 analyze\_cs\_type\_hook().
		.2 AddTemplateClassR().
		.2 \mc{\footnotesize{(次ページに続く)}}.
	}
	\end{minipage}\end{narrow}
\end{narrow}
\newpage
\bf{関数一覧(続き)}
\begin{narrow}[\WID]
	\begin{narrow}[20pt]\begin{minipage}{.8\textwidth}
	\dirtree{%
		.1 {\hspace{-10mm}top()}.
		.3 FindTemplateClassMember().
		.4 AddTemplateClassR() \RECURSE.
		.3 find\_template\_instances().
		.3 AddTemplateClassR() \RECURSE.
		.2 mark\_function\_generation().
		.2 DescImp() \LATER.
		.2 IfImp() \LATER.
		.2 TypeMapImp().
		.3 get\_node\_info() \DESCRIBED.
	}
	\end{minipage}\end{narrow}
\end{narrow}

\bigskip
\bf{関数一覧(続き)}
\begin{narrow}[\WID]
	\begin{narrow}[20pt]\begin{minipage}{.8\textwidth}
	\dirtree{%
		.1 {\hspace{-10mm}DescImp()}.
		.2 get\_node\_info() \DESCRIBED.
		.2 generate\_new\_class().
		.3 is\_newable\_class().
		.4 get\_node\_info() \DESCRIBED.
		.3 is\_virtual().
		.3 generate\_constructor().
		.4 get\_node\_info() \DESCRIBED.
		.4 make\_wrapper\_name().
		.5 make\_wrapper\_type() \DESCRIBED.
		.5 make\_wrapper\_name\_type\_part().
		.6 strip\_type\_modifier().
		.7 strip\_type\_modifier \RECURSE.
		.7 analyze\_type\_modifier().
		.8 strip\_type\_modifier\_1().
		.4 need\_generate\_constructor().
		.3 free\_struct\_info().
		.3 generate\_type\_conversion\_operator().
		.4 get\_struct\_info().
		.5 string\_on\_heap().
		.2 \mc{\footnotesize{(次ページに続く)}}.
	}
	\end{minipage}\end{narrow}
\end{narrow}
\newpage
\bf{関数一覧(続き)}
\begin{narrow}[\WID]
	\begin{narrow}[20pt]\begin{minipage}{.8\textwidth}
	\dirtree{%
		.1 {\hspace{-10mm}DescImp()}.
		.5 FindNodeByAttrR() \RECURSE.
		.5 get\_node\_info() \DESCRIBED.
		.5 make\_wrapper\_name() \DESCRIBED.
		.4 generate\_type\_conversion\_operator\_copy\_members().
		.3 expand\_operator\_macro().
		.3 default\_operator\_func\_name().
		.3 count\_extra\_fields\_in\_operator\_def().
		.3 operator\_type\_analyzer().
		.4 dimension\_and\_type().
		.3 generate\_operator().
		.4 generate\_operator\_is\_type\_scalar().
		.4 improve\_type\_representaion().
		.5 replace\_all().
		.5 replace\_one\_at().
		.4 generate\_indexer().
		.3 has\_print\_facility().
		.4 force\_generate\_tostring().
		.3 print\_facility\_name().
		.3 generate\_to\_string().
		.2 FindNode().
		.2 analyze\_cs\_type\_hook\_2().
		.2 make\_wrapper\_name() \DESCRIBED.
		.2 generate\_wrapper\_accessor().
		.3 generate\_accessor\_for\_type\_vector\_intrinsic().
		.4 make\_wrapper\_name() \DESCRIBED.
		.4 make\_wrapper\_type() \DESCRIBED.
		.4 make\_wrapper\_name\_type\_part() \DESCRIBED.
		.3 generate\_accessor\_for\_type\_array\_intrinsic().
		.4 make\_wrapper\_name() \DESCRIBED.
		.4 make\_wrapper\_type() \DESCRIBED.
		.2 \mc{\footnotesize{(次ページに続く)}}.
	}
	\end{minipage}\end{narrow}
\end{narrow}
\newpage
\bf{関数一覧(続き)}
\begin{narrow}[\WID]
	\begin{narrow}[20pt]\begin{minipage}{.8\textwidth}
	\dirtree{%
		.1 {\hspace{-10mm}DescImp()}.
		.4 make\_wrapper\_name\_type\_part() \DESCRIBED.
		.3 generate\_accessor\_for\_type\_intrinsic\_pointer().
		.4 is\_already\_generated().
		.3 generate\_accessor\_for\_type\_intrinsic\_bool().
		.4 is\_already\_generated().
		.3 generate\_accessor\_for\_type\_intrinsic().
		.4 is\_already\_generated().
		.3 generate\_accessor\_for\_type\_vector\_string().
		.3 generate\_accessor\_for\_type\_array\_string().
		.3 generate\_accessor\_for\_type\_string().
		.4 is\_already\_generated().
		.4 generate\_string\_get().
		.4 generate\_string\_set().
		.3 generate\_accessor\_for\_type\_struct\_enum().
		.3 generate\_accessor\_for\_type\_struct\_pointer().
		.3 generate\_accessor\_for\_type\_vector\_struct().
		.4 make\_wrapper\_name() \DESCRIBED.
		.4 make\_wrapper\_type() \DESCRIBED.
		.4 make\_wrapper\_name\_type\_part() \DESCRIBED.
		.3 generate\_accessor\_for\_type\_array\_struct().
		.4 make\_wrapper\_name() \DESCRIBED.
		.4 make\_wrapper\_type() \DESCRIBED.
		.4 make\_wrapper\_name\_type\_part() \DESCRIBED.
		.3 generate\_accessor\_for\_type\_struct.
		.2 generate\_wrapper\_accessor\_struct().
		.3 make\_wrapper\_type() \DESCRIBED.
		.3 make\_wrapper\_name() \DESCRIBED.
		.3 make\_wrapper\_name\_type\_part() \DESCRIBED.
		.3 create\_wrapper\_accessor\_file.
		.3 strip\_type\_modifier() \DESCRIBED.
		.2 \mc{\footnotesize{(次ページに続く)}}.
	}
	\end{minipage}\end{narrow}
\end{narrow}
\newpage
\bf{関数一覧(続き)}
\begin{narrow}[\WID]
	\begin{narrow}[20pt]\begin{minipage}{.8\textwidth}
	\dirtree{%
		.1 {\hspace{-10mm}DescImp()}.
		.3 FindNodeByAttrR() \RECURSE.
		.2 generate\_accessor\_for\_type\_intrinsic\_pointer() \DESCRIBED.
		.2 generate\_accessor\_for\_type\_intrinsic\_bool() \DESCRIBED.
		.2 generate\_accessor\_for\_type\_intrinsic() \DESCRIBED.
		.2 generate\_accessor\_for\_type\_string() \DESCRIBED.
		.2 generate\_accessor\_for\_type\_struct() \DESCRIBED.
		.2 generate\_accessor\_for\_type\_struct\_enum() \DESCRIBED.
		.2 generate\_accessor\_for\_type\_struct\_pointer() \DESCRIBED.
		.2 generate\_accessor\_for\_type\_enum	().
		.2 FindNodeByAttrR() \RECURSE.
		.2 FP\_generate\_enum\_def().
		.3 get\_node\_info().
		.2 FindNodeR() \DESCRIBED.
		.2 IfImp \LATER.
		.2 generate\_new\_class\_struct().
		.3 get\_struct\_info.
		.3 is\_newable\_class() \DESCRIBED.
		.3 is\_virtual() \DESCRIBED.
		.3 resolve\_inheritance().
		.4 FindNodeByAttrR() \RECURSE.
		.4 resolve\_inheritance() \RECURSE.
		.3 generate\_type\_conversion\_operators().
		.4 get\_struct\_info.
		.4 generate\_type\_conversion\_operator\_copy\_members() \DESCRIBED.
	}
	\end{minipage}\end{narrow}
\end{narrow}
\bigskip
\bf{関数一覧(続き)}
\begin{narrow}[\WID]
	\begin{narrow}[20pt]\begin{minipage}{.8\textwidth}
	\dirtree{%
		.1 {\hspace{-10mm}IfImp()}.
		.2 get\_node\_info() \DESCRIBED.
		.2 generate\_new\_class.
		.2 \mc{\footnotesize{(次ページに続く)}}.
	}
	\end{minipage}\end{narrow}
\end{narrow}
\newpage
\bf{関数一覧(続き)}
\begin{narrow}[\WID]
	\begin{narrow}[20pt]\begin{minipage}{.8\textwidth}
	\dirtree{%
		.1 {\hspace{-10mm}IfImp()}.
		.2 FindNode() \DESCRIBED.
		.2 analyze\_cs\_type\_hook\_2() \DESCRIBED.
		.2 replace\_template\_parameter().
		.3 replace\_template\_parameter\_1().
		.4 replace\_template\_parameter\_2().
		.5 replace\_template\_parameter\_string().
		.5 analyze\_cs\_type\_hook() \DESCRIBED.
		.2 FindNodeByAttrR() \RECURSE.
		.2 generate\_string\_set() \DESCRIBED.
		.2 generate\_string\_get() \DESCRIBED.
		.2 argname().
		.2 make\_wrapper\_name() \DESCRIBED.
		.2 generate\_wrapper\_accessor\_struct.
		.2 is\_special\_struct().
		.2 FP\_generate\_enum\_def() \DESCRIBED.
	}
	\end{minipage}\end{narrow}
\end{narrow}
\bigskip
\bf{関数一覧(続き)}
\begin{narrow}[\WID]
	\begin{narrow}[20pt]\begin{minipage}{.8\textwidth}
	\dirtree{%
		.0 {\hspace{-10mm}\it{top level}}.
		.1 unqualified\_name().
		.1 cs\_qualified\_name().
		.1 analyze\_error().
		.1 analyze\_skip().
		.1 strip\_whites().
		.1 is\_if\_class().
		.1 is\_basic\_type().
		.1 create\_wrapper\_accessor\_file().
		.2 make\_wrapper\_tmp\_filename().
		.1 is\_file\_empty().
		.1 generate\_constructor\_with\_full\_members().
		.2 strip\_type\_modifier() \DESCRIBED.
		.1 \mc{\footnotesize{(次ページに続く)}}.
	}
	\end{minipage}\end{narrow}
\end{narrow}
\newpage
\bf{関数一覧(続き)}
\begin{narrow}[\WID]
	\begin{narrow}[20pt]\begin{minipage}{.8\textwidth}
	\dirtree{%
		.0 {\hspace{-10mm}\it{top level}}.
		.1 generate\_accessors\_for\_parents().
		.2 get\_node\_info() \DESCRIBED.
		.2 get\_struct\_info.
		.2 wrapper\_key.
		.2 generate\_wrapper\_accessor.
		.1 overname().
		.1 element\_type().
		.1 dimension().
		.1 dimension\_ane\_type().
	}
	\end{minipage}\end{narrow}
\end{narrow}

\bigskip
\subsection{ファイル出力制御}
出力ファイルのファイルポインタは、変数\tt{fps}及び\tt{gip}に格納されている。

\vspace{0.5\baselineskip}
\begin{narrow}\begin{tabular}{ccll}\hline
	FP & 参照マクロ名 & \multicolumn{2}{c}{出力ファイル}\\\hline
	\tt{fps[0]} & \tt{CPP} & \FILE{SprExport/*.cpp} & \CPP source file\\
	\tt{fps[1]} & \tt{CS}  & \FILE{SprCSharp/*.cs}  & \CS source file\\
	\tt{fps[2]} & \tt{CSP} & \FILE{SprImport/*.cs}  & \CS source file\\
	\tt{gip} & なし & \FILE{.info}  & デバッグ用情報ファイル\\\hline
\end{tabular}\end{narrow}

\bigskip
\subsection{デバッグ出力制御}
デバッグ用の情報は、生成するファイル上にコメント行として出力される。
どのファイルに出力するかは次のフラグ定数で制御する。

\vspace{0.5\baselineskip}
\begin{narrow}\begin{tabular}{ll}\hline
	定数 & 出力ファイル\\\hline
	\tt{FD\_CPP}  & \FILE{SprExport/*.cpp}\\
	\tt{FD\_CS}   & \FILE{SprCSharp/*.cs}\\
	\tt{FD\_CSP}  & \FILE{SprImport/*.cs}\\
	\tt{FD\_LOG}  & \FILE{swig\_sprcs\_<module>.log}\\
	\tt{FD\_INFO} & \FILE{CS.info} (\tt{typedef}情報\\
	\tt{FD\_ERR}  & \tt{stderr}\\
	\tt{FD\_ALL}  & \verb+FD_CPP | FD_CS | FD_CSP+\\\hline
\end{tabular}\end{narrow}

\bigskip
\subsection{マクロ}
\begin{narrow}[\WID]
	\begin{tabular}{ll}
	    \multicolumn{2}{l}{\tt{ALERT(node\_or\_str,message)}
		(Alert) の出力}\\
	    \tt{FREE\_UNMANAGED\_MEMORY}
		& stringを返すために\CPP 側に一時的に確保した領域を\\
		& 解放するコードを有効にする(メモリリークを抑える)\\
	    \tt{GENERATE\_TRY\_CATCH}
		& \CPP 側での関数呼び出しで発生した例外を補足する\\
		& コードを生成する\\
	    \tt{ADOPT\_TEMPLATE\_CLASS}
		& template classを有効にする (未デバッグ)\\
	    \tt{GENERATE\_OPT\_CONSTRUCTOR}
		& 全メンバを引数とするconstructorを生成する\\
	    \tt{USE\_SIGNATURE\_FILE}
		& 関数のシグナチャーを記録したファイルを生成する\\
		& (関数の重複生成を抑止するために使用)\\
	    \tt{CAN\_GET\_RETURNED\_ARRAY\_SIZE}
		& 関数が配列へのポインタを返す場合にその配列のサイズ\\
		& を得る手段があるかどうか\\
		& (現状では手段がない) (あったときのコードは未作成)\\
	    \tt{DLLIMPORT} & \tt{DllImport}行の定義\\
	\end{tabular}

	\bigskip
	\begin{tabular}{ll}
	    \tt{EQ(p,q)}  & 文字列の比較(一致でtrue)。
				ポインタが\tt{NULL}だと例外発生\\
	    \tt{EQc(p,q)} & 文字列の比較(一致でtrue)。
				ポインタが\tt{NULL}だと\tt{false}\\
	    \tt{EQ2(p,q)} & 先頭2文字の比較(一致でtrue)。
				ポインタが\tt{NULL}だと例外発生。\\
	    \tt{ENDWITH(p,s)} & 第1文字列が第2文字列で終わっているときtrue\\
	    \tt{BEGINWITH(p,s)} & 第1文字列が第2文字列で始まっているときtrue\\
	    \tt{NON\_NULL(s)} & 引数が\tt{NULL}ならは空文字(\verb*| |)に置き換え\\
	    \tt{ALIGNMENT}   & メモリ境界\\
	    \tt{MAX\_NAMELEN} & 識別子長の上限値(チェックなしで使っている箇所あり)\\
	    \tt{HACK} & \tt{UTTimerIf::TimerFunc}に関する特別処理\\
	\end{tabular}
	\begin{narrow}[\WID]\small{%
		\begin{description}
		  \item	[※] マクロ\tt{ALIGNMENT}は
			\tt{size\_t}を\CS のどの型にするかに用いている。
			ただし\FILE{sprcs.cpp}をビルドするplatformで決まるので、
				生成された\CS ソースをビルドするplatformと合わせないと
			結果が間違ってくる。
			\CS 側の条件付きコンパイルに移行できれば解決する(?)。
		\end{description}
	}\end{narrow}

	\medskip
	try-catchコード出力関連

	\vspace{.5ex}
	\begin{tabular}{ll}
	    \tt{TC\_PTR}  & 未使用\\
	    \tt{TC\_VAL}  & 未使用\\
	    \tt{TC\_I(n)} & インデント用空白文字制御\\
	\end{tabular}

	\bigskip
	以下はデバッグ用マクロ\\
	\vspace{.5ex}
	\begin{tabular}{p{80pt}l}
	    \tt{SNAP}	& 次のデバッグ処理を有効にする\\
			& \hspace{10pt}ファイルポインタ\tt{snap\_xxx},
			  \tt{snap\_xxx\_wrap} (file scope)\\
			& \hspace{10pt}マクロ\tt{SNAP\_ANA\_PATHx},
			  \tt{WRAPPER\_NAME\_PRINT}\\
	    \tt{DUMP}	& マクロ\tt{DUMP\_NODE\_INFO}を有効にする\\
	    \tt{DUMP\_TREE} & ツリーダンプ(簡易版)を出力する(\FILE{.info}ファイル)\\
	    \tt{DUMP\_NODE} & ノードダンプを有効にする\\
	    \tt{DUMP\_STRUCT} & 構造体ダンプを有効にする\\
	    \tt{SHOW\_ALL\_TYPES}
			& Desc/Ifの子ノードで処理をスキップするノードもダンプする\\
	    \tt{GATHER\_INFO}
			& デバッグ用情報ファイル(\FILE{.info})に情報を出力する\\
	\end{tabular} \\
	\begin{tabular}{ll}
	    \tt{BREAK\_NODE\_NO}
			& ノード番号によるブレークポイントを有効にする\\
			& {\small{※ ノード番号を設定する}}\\
			& {\small{※ 関数\FUNC{debug\_break\_at()}に
				ブレークポイントを設定する必要あり}}\\
	\end{tabular}\\
	\begin{tabular}{ll}
	    \tt{SNAP\_AT\_LINE(a,b)} & 現在行番号スナップマクロ\\
	    \tt{SNAP\_ANA\_PATH2(a,b,c,d)} & スナップショットマクロ(4引数)\\
	    \tt{SNAP\_ANA\_PATH1(a,b,c)}   & スナップショットマクロ(3引数)\\
	    \tt{WRAPPER\_NAME\_PRINT(a,b,c,d,e,f)}
					 & ラッパクラス名のスナップショット\\
	    \tt{DUMP\_NODE\_INFO(a,b,c,d)} & ノード情報のダンプ\\
	    \tt{DUMP\_STRUCT\_INFO(a,b,c)} & 構造体情報のダンプ\\
	\end{tabular}
\end{narrow}

\bigskip
\subsection{構造体(新たに定義したもの)}
\begin{enumerate}
  \item	ノード解析情報\\
	\vspace{.5ex}
	\begin{tabular}{p{5pt}ll}
	    \multicolumn{3}{l}{\tt{struct nodeinfo\_t \{}}\\
	    & \tt{int no;}	     & ノード番号\UDAGGER{1}\\
	    & \tt{char* sym\_name;}   & ノードのsym:name属性\UDAGGER{1}\\
	    & \tt{char* name;}       & ノードのname属性\UDAGGER{1}\\
	    & \tt{char* decl;}       & ノードのdecl属性\UDAGGER{1}\\
	    & \tt{char* access;}     & ノードのaccess属性\UDAGGER{1}\\
	    & \tt{char* storage;}    & ノードのstorage属性\UDAGGER{1}\\
	    & \tt{char* kind;}       & ノードのkind属性\UDAGGER{1}\\
	    & \tt{char* type;}       & ノードの type 属性\UDAGGER{1}\\
	    & & \tt{is\_function}なら\tt{uq\_type}から取り出す\UDAGGER{2}\\
	    & \tt{char* uq\_name;}    & \tt{name}から
					\STR{::}以前をすべて除いたもの
					\UDAGGER{1}\\
	    & \tt{char* uq\_type;}    & \tt{type}から
					\STR{Spr::}と\STR{std::}を除いたもの
					\UDAGGER{1}\\
	    & \tt{char* overname;}   & ノードのsym:overname属性\\
	    &			     &	(関数のオーバーロード) \UDAGGER{1}\\
	\end{tabular}

	\begin{tabular}{p{5pt}ll}
	    & \tt{char* cpp\_name;}   & \tt{uq\_name}、または\tt{name\_hook\_table}で
					置き換え\\
	    &			     & たもの\UDAGGER{4}\\
	    & \tt{char* cpp\_type;}   & 解析した情報から再構成する\UDAGGER{3}\\
	    & \tt{char* cs\_name;}    & \tt{uq\_name}の\STR{::}を\STR{\_}で置き換えたもの
					\UDAGGER{4}\\
	    & \tt{char* cs\_type;}    & \tt{TypeConv}テーブルで\tt{uq\_type}に対応するもの
					\UDAGGER{2}\\
	    & \tt{char* cs\_im\_type;} & \tt{cs\_type}から\STR{::}以前を取り除いたもの
					\UDAGGER{5}\\
	    & \tt{char* cs\_marshaltype;}
				     & \tt{TypeConv}テーブルで\tt{uq\_type}に
					対応するもの\\
	    &			     & \tt{is\_array}のときは特別\UDAGGER{6}\\
	    & \tt{int is\_typedef;}   & \tt{kind==typedef}のときtrue \UDAGGER{2}\\
	    & \tt{int is\_variable;}  & \tt{kind==variable}または\tt{uq\_type}が基本型、\\
	    &			     & \tt{void*}、\tt{string}のいずれかのときtrue
					\UDAGGER{2}\\
	    & \tt{int is\_intrinsic;} & \tt{uq\_type}が基本型のときtrue\\
	    & \tt{int is\_vector;}    & \tt{uq\_type}が\STR{[std::]vector<...>}ならtrue
					\UDAGGER{8}\\
	    & \tt{int is\_string;}    & \tt{uq\_type==string}または
					\tt{uq\_type==string}なら\\
	    &			     & true\ UDAGGER{2}\\
	    & \tt{int is\_function;}  & \tt{kind==function}かつ
					\tt{kind!=typedef}なら\\
	    &			     &	true \UDAGGER{1}\\
	    & \tt{int is\_struct;}    & \tt{kind==struct}のときtrue \UDAGGER{1}\\
	    &			     & または\tt{TypeConv}テーブルに見つからないとき
					true \UDAGGER{2}\\
	    & \tt{int is\_array;}     & \tt{array\_size}がnon--NULLなら
					その数値\UDAGGER{7}\\
	    & \tt{int is\_pointer;}   & \tt{pointer\_level\orgRA 0}ならtrue \UDAGGER{7}\\
	    & \tt{int is\_reference;} & \tt{decl}が\STR{r.}を含んでいたら
					true \UDAGGER{7}\UDAGGER{9}\\
	    & \tt{int is\_const;}     & \tt{decl}が\STR{q(const)}を含んでいたら
					true \UDAGGER{9}\\
	    & \tt{int is\_volatile;}  & \tt{cpp\_type}が\STR{q(volatile)}を含んでいたら
					true \UDAGGER{9}\\
	    & \tt{int is\_enum;}	     & \tt{uq\_type}が\STR{enum}で始まっていたら
					true \UDAGGER{10}\\
	    & \tt{int is\_void;}	     & \tt{uq\_type==void}かつ\tt{!is\_pointer}なら
					true \UDAGGER{1}\\
	    & \tt{int is\_void\_ptr;}  & \tt{uq\_type==void}かつ\tt{is\_pointer}なら
					true \UDAGGER{1}\\
	    & \tt{int is\_bool;}	     & \tt{uq\_type==bool}のときtrue \UDAGGER{1}\\
	    & \tt{int is\_static;}    & \tt{storage==static}のときtrue \UDAGGER{1}\\
	    & \tt{int is\_virtual;}   & \tt{storage==virtual}のときtrue \UDAGGER{1}\\
	    & \tt{char* array\_size;} & \tt{decl}が\STR{a(...)}を含んでいたらその数値
					\UDAGGER{11}\\
	    & \tt{int pointer\_level;}& \tt{decl}が\tt{p.}を含んでいる回数
					\UDAGGER{7}\UDAGGER{9}\\
	    & \tt{int num\_args;}     & \tt{decl}が\STR{f(...)}を含んでいるとき
					その引数の個数\UDAGGER{12}\\
	    & \multicolumn{2}{l}{\tt{struct nodeinfo\_t* funcargs;}}\\
	    &			    & \tt{decl}の\STR{f(...)}を解析して設定
					\UDAGGER{12}\UDAGGER{13}\\
	    \multicolumn{3}{l}{\tt{\};}}\\
	\end{tabular}

	\medskip
	\let\orgArrayStretch=\arraystretch
	\def\arraystretch{0.9}
	{\small{\begin{tabular}{ll}
	    \UDAGGER{1}  & \tt{get\_node\_info()}で設定\\
	    \UDAGGER{2}  & \tt{set\_type\_info()}で設定\\
	    \UDAGGER{3}  & \tt{analyze\_cpp\_type\_repr()}で設定\\
	    \UDAGGER{4}  & \tt{analyze\_name\_hook()}で設定\\
	    \UDAGGER{5}  & \tt{cs\_type\_hook()}で設定\\
	    \UDAGGER{6}  & \tt{analyze\_marshaltype()}で設定\\
	    \UDAGGER{7}  & \tt{analyze\_syntax()}で設定\\
	    \UDAGGER{8}  & \tt{analyze\_vector()}で設定\\
	    \UDAGGER{9}  & \tt{analyze\_type\_modifier()}で設定\\
	    \UDAGGER{10} & \tt{analyze\_enum()}で設定\\
	    \UDAGGER{11} & \tt{analyze\_array()}で設定\\
	    \UDAGGER{12} & \tt{analyze\_init\_funcargs()}で設定\\
	\end{tabular}}}
	\let\arraystretch\orgArrayStretch
	\bigskip

  \item	データ型変換テーブル(定数)\\
	\vspace{.5ex}
	\begin{tabular}{p{5pt}p{100pt}l}
	    \multicolumn{3}{l}{\tt{struct typeconv\_t \{}}\\
	    & \tt{int kind;}	   & 種別：\\
	    & &			\small{1: 基本型, 2: void*,
				3: string, 4: vector, 5: それ以外}\\
	    & \tt{char* cpp\_type;} & \CPP における型表現\\
	    & \tt{char* cs\_type;}  & \CS における型表現\\
	    & \tt{char*}	    & \STR{[MarshalAs(UnmanagedType.XX)]}の
				      \STR{XX}に\\
	    & \tt{cs\_marshaltype;} & 代入する型表現\\
	    & \tt{int count;}	    & 未使用\\
	    \multicolumn{3}{l}{\tt{\};}}\\
	\end{tabular}
	\medskip

  \item	型修飾子テーブル(定数)\\
	\vspace{.5ex}
	\begin{tabular}{p{5pt}p{100pt}l}
	    \multicolumn{3}{l}{\tt{static const char* type\_modifiers[] = \{}}\\
	    & \tt{"p."},	   & ポインタ\\
	    & \tt{"r."},	   & 参照\\
	    & \tt{"q(const).},	   & const\\
	    & \tt{"qconst."},	   & const\\
	    & \tt{"q(volatile)."}, & volatile\\
	    & \tt{"qvolatile."},   & volatile\\
	    & \tt{NULL} &\\
	    \multicolumn{3}{l}{\tt{\};}}\\
	\end{tabular}
	\medskip

  \item	クラスメンバ変数情報
	\vspace{-1ex}
	\begin{longtable}{p{5pt}p{100pt}l}
	    \multicolumn{3}{l}{\tt{struct struct\_info\_t \{}}\\
	    & \tt{char* name;}	    & クラス名\\
	    & \tt{int num\_members;} & メンバ変数個数\\
	    & \multicolumn{2}{l}{\tt{struct struct\_members\_info\_t** members;}}\\
	    & &			メンバ情報テーブル\\
	    \multicolumn{3}{l}{\tt{\};}}\\
	    \multicolumn{3}{l}{\tt{struct struct\_members\_info\_t \{}}\\
	    & \tt{Node* node;} & ノードポインタ\\
	    & \tt{char* name;} & \small{ノード情報のコピー(\FUNC{get\_node\_info()}で取得)}\\
	    & \tt{char* cs\_name;}    & 同上\\
	    & \tt{char* cs\_type;}    & 同上\\
	    & \tt{char* cpp\_name;}   & 同上\\
	    & \tt{char* cpp\_type;}   & 同上\\
	    & \tt{int is\_bool;}      & 同上\\
	    & \tt{int is\_vector;}    & 同上\\
	    & \tt{int is\_array;}     & 同上\\
	    & \tt{int is\_string;}    & 同上\\
	    & \tt{int is\_struct;}    & 同上\\
	    & \tt{int is\_pointer;}   & 同上\\
	    & \tt{int is\_reference;} & 同上\\
	    \multicolumn{3}{l}{\tt{\};}}\\
	\end{longtable}
	\medskip

  \item	マップ変数(新たに定義したもの)
	\def\YA{\hspace{5pt}\RARROW\hspace{5pt}}
	\begin{narrow}[10pt]
		\tt{map<char*, char*> typedef\_map;}
			\YA\small{key: typedef 名, value: typedef 定義}\\
		\tt{map<char*, int> class\_map;}
			\YA\small{[key: class/struct 名, value: 1]}\\
		\tt{map<char*, int> enum\_map;}
			\YA\small{key: enum 名, value: 1}\\
		\tt{map<char*, int> intf\_map;}
			\YA\small{key: If/IfInfo 名, value: 1}\\
		\tt{map<char*, int> vintf\_map;}
			\YA\small{key: SPR\_VIFDEF 名, value: 1}\\
		\tt{map<string, int> delegate\_key\_map;}
			\YA\small{key: 関数引数名, value: 1}\\
		\tt{map<string, string> delegate\_func\_map;}
			\YA\small{key: 関数引数名, value: 関数引数名}\\
		\tt{map<string, string> delegate\_type\_map;}
			\YA\small{key: 関数引数名, value: 関数型}\\
		\tt{map<string, string> delegate\_args\_map;}\\
			\hspace{100pt}
			\YA\small{key: 関数引数名, value: 関数引数の引数}\\
		\tt{map<string, int> signature\_map;}
			\YA\small{key: 関数引数名＋関数引数の引数, value: 1}\\
		\tt{map<string, string> signature\_args\_map;}\\
			\hspace{100pt}
			\YA\small{key: 関数引数名, value: 関数引数の引数(cast形式)}\\
		\tt{map<string, int> wrapper\_map;}
			\YA\small{key: wrapper 名, value: 1}\\
		\tt{map<string, int> fd\_pair\_map;}
			\YA\small{key: クラス名−末尾文字, value: 見つけた数}\\
		\hspace{100pt}
		\small{※ クラス名の末尾が\STR{f}か\STR{d}のもののみが対象}\\
		\tt{map<string, string> operator\_macros\_map;}\\
			\hspace{100pt}
			\YA\small{key: マクロ名, value: マクロ定義}\\
		\tt{map<string, int> function\_generation\_map;}
			\YA\small{key: 関数名, value: 1}\\
		\tt{map<string, int> accessor\_generation\_map;}
			\YA\small{key: 要素名, value: 1}\\
		\tt{map<string, NodeInfo> class\_node\_map;}
			\YA\small{key: クラス名, value: ノード情報}\\
		\tt{map<string, char*> class\_parent\_map;}
			\YA\small{key: クラス名, value: 親クラス名}\\
	\end{narrow}
\end{enumerate}

\subsection{処理の概要}
\def\SPC{3pt}

\subsubsection{DescImp()}
\begin{enumerate}
  \item	新しいクラスの生成開始\\
	すべての子ノード(cdecl)について
	\begin{narrow}[\WID]
		\begin{enumerate}\def\labelenumiii{\arabic{enumiii})}
		  \item	次のノードはスキップする
			\begin{itemize}\setlength{\itemindent}{\SPC}
			  \item	\tt{\%ignore}
			  \item	変数でない または 関数である
			  \item	staticである(ただし\tt{static int}は
				\tt{const int}にする)
			  \item	\tt{protected}
			  \item	\tt{private}
			  \item	\tt{typedef}された関数ポインタ
			\end{itemize}
		  \item	次のような場合分けをしてコードを生成する
			\begin{itemize}\setlength{\itemindent}{\SPC}
			  \item	\tt{vector} or \tt{array}
			  \item	基本型
				\begin{itemize}\setlength{\itemindent}{\SPC}
				  \item	ポインタ
				  \item	\tt{bool}
				  \item	その他
				\end{itemize}
			  \item	\tt{string}
			  \item	\tt{struct}
				\begin{itemize}\setlength{\itemindent}{\SPC}
				  \item	\tt{enum}
				  \item	ポインタ
				  \item	その他
				\end{itemize}
			  \item	\tt{enum}
			\end{itemize}
		\end{enumerate}
	\end{narrow}
  \item	クラス直下の\tt{enum}
  \item	クラス生成終了（
  \item	\tt{Struct}クラスの生成
\end{enumerate}

\subsubsection{IfImp()}
\begin{enumerate}
  \item	新しいクラスの生成開始\\
	すべての子ノード(cdecl)について
	\begin{narrow}[\WID]
		\begin{enumerate}\def\labelenumiii{\arabic{enumiii})}
		  \item	次のノードはスキップする
			\begin{itemize}\setlength{\itemindent}{\SPC}
			  \item	関数でない
			  \item	\tt{private}
			  \item	\tt{virtual}
			  \item	\tt{operator}
			  \item	\tt{UTStack}で始まる関数
			\end{itemize}
		  \item	関数引数をdelegateするための前処理
		  \item	ポインタを返す関数が実際に配列を返す場合\\
			(\tt{\%feature("returns\_array")}の処理)
		  \item	\tt{typedef}された関数はスキップする
		\end{enumerate}
		\medskip

		\it{---SprExport---}
		\begin{enumerate}\def\labelenumiii{\arabic{enumiii})}
		  \item	関数定義
		  \item	仮引数並び
		  \item	実引数に関する前処理
			\begin{itemize}\setlength{\itemindent}{\SPC}
			  \item	\tt{vector} or \tt{array}
			  \item	基本型
			  \item	\tt{string}
			  \item	\tt{struct}
			\end{itemize}
		  \item	関数本体
			\begin{itemize}\setlength{\itemindent}{\SPC}
			  \item	左辺側
			  \item	右辺側
			\end{itemize}
		  \item	関数値に関する処理
			\begin{itemize}\setlength{\itemindent}{\SPC}
			  \item	\tt{vector} or \tt{array}
			  \item	基本型
			  \item	\tt{string}
			  \item	\tt{struct}
			\end{itemize}
		\end{enumerate}
		\medskip

		\it{---SprCSharp---}
		\begin{enumerate}\def\labelenumiii{\arabic{enumiii})}
		  \item	関数引数の場合の前処理
		  \item	関数定義
		  \item	引数並び
		  \item	引数に関する前処理
			\begin{itemize}\setlength{\itemindent}{\SPC}
			  \item	\tt{string}
			  \item	その他
			\end{itemize}
		  \item	関数本体
			\begin{itemize}\setlength{\itemindent}{\SPC}
			  \item	左辺側
			  \item	右辺側
			\end{itemize}
		  \item	引数並び
		  \item	関数値に関する後処理
			\begin{itemize}\setlength{\itemindent}{\SPC}
			  \item	\tt{bool}
			  \item	\tt{char*}
			  \item	\tt{string}
			  \item	\tt{vector} or \it{array}
			  \item	\tt{struct}
			  \item	\tt{void}以外
			\end{itemize}
		\end{enumerate}
		\medskip

		\it{---SprImport---}
		\begin{enumerate}\def\labelenumiii{\arabic{enumiii})}
		  \item	関数宣言
		  \item	引数並び
		\end{enumerate}
	\end{narrow}

  \item	\tt{enum}
\end{enumerate}

\subsubsection{argname()}
\begin{narrow}[15pt]
	引数を区別するための名前を作成
\end{narrow}

\subsubsection{FindNodeByAttrR(),
	       FindNodeR(),
	       FindNode()}
\medskip
\begin{narrow}[15pt]
	指定されたノードを見つける
\end{narrow}

\subsubsection{is\_if\_class()}
\begin{narrow}[15pt]
	ノードのtypeが\DQuote{include}、かつnameが\DQuote{\\\\include\\\\}を
	含むときtrue
\end{narrow}

\subsubsection{resolve\_inheritance()}
\begin{narrow}[15pt]
	継承元クラス名の取得
\end{narrow}

\subsubsection{is\_special\_struct()}
\begin{narrow}[15pt]
	型名が\tt{If}で終わるか、
	または\tt{"IfInfo", "FWApp", "PHCollisionListener"}のいずれかならtrue
\end{narrow}

\subsubsection{top()}
\begin{enumerate}
  \item	出力ファイルのオープン(\tt{fps}, \tt{gip})
  \item	\tt{USE\_SIGNATURE\_FILE}が定義されていたら、シグナチャーファイルを
	読み込んで\tt{signature\_map}に記録する
  \item	\tt{typedf\_map}, \tt{typedef\_inverse\_map}の作成
  \item	\tt{module}ノードに対して、
	\begin{itemize}
	  \item	\tt{SprExport}ファイルに、\tt{\#include}, \tt{using}, \tt{extern}
		情報を出力する
	  \item	\tt{SprCSharp}ファイルに、\tt{using}, \tt{\#pragma}
		情報を出力する
	  \item	\tt{SprImport}ファイルに、\tt{using}, \tt{namespace}
		情報を出力する
	\end{itemize}
  \item	\tt{include}ノード内の\tt{class}ノード及びその子孫ノードに対して、
	\begin{itemize}
	  \item	\tt{feature:ignore}は無視
	  \item	typeが\tt{constructor}か\tt{cdecl}ならば、
		\tt{intfs}, \tt{vintfs}, \tt{absts} 及びそれらのmapに記録
	  \item	kindが\tt{struct}か\tt{class}ならば、
		\tt{descs}及び\tt{class\_map}に記録
	  \item	enum名を\tt{enam\_map}に記録
	  \item	\tt{Vec3f}/\tt{Vec3d}のようにfloat/doubleのペアになっている
		クラスを\tt{fd\_pair\_map}に記録
	  \item	attributeが\tt{feature:operator:macro}のノードから
		マクロの定義を取り出し\tt{operator\_macros\_map}に記録
	\end{itemize}
  \item	クラスノードとその親の情報を収集し、
	\tt{class\_node\_map}及び\tt{class\_parent\_map}に記録
  \item	\tt{descs}に記録されたノードに対して\FUNC{DescImp()}を呼び出す
  \item	\tt{externalObjs}に記録されたノードに対して\FUNC{DescImp()}を呼び出す
  \item	\tt{intfs}及び\tt{vintfs}に記録されたノードに対して
	\FUNC{IfImp()}を呼び出す
  \item	出力ファイルの終了処理
\end{enumerate}	

\subsubsection{create\_wrapper\_accessor\_file(),
	       make\_wrapper\_tmp\_filename()}
\medskip
\begin{narrow}[15pt]
	wrapper生成用ファイルの作成 (ファイルポインタを\tt{fps}に返す)
\end{narrow}	

\subsubsection{mark\_function\_generation()}
\begin{narrow}[15pt]
	次の条件を満たす関数を生成済みマップに登録
	\begin{itemize}
	  \item	関数名の末尾が\tt{If}でも\tt{Desc}でもない。
	  \item	\tt{.i}ファイルに\tt{feature:struct}で登録されていない。
	  \item	\tt{constructor}でない
	  \item	ノードkindがfunctionである。
	\end{itemize}
\end{narrow}

\subsubsection{generate\_new\_class\_struct()}
\begin{narrow}[15pt]
	\tt{class Vec3dStruct}など、
	{f}/{d}ペアをもつクラスの\CS\ local版クラス生成
\end{narrow}

\subsubsection{generate\_type\_conversion\_operator(),\\
	       generate\_type\_conversion\_operators(),\\
	       generate\_type\_conversion\_operator\_copy\_members()}
\medskip
\begin{narrow}[15pt]
	暗黙の型変換定義の生成
\end{narrow}

\subsubsection{generate\_new\_class()}
\begin{narrow}[15pt]
	クラス生成コードの生成
	\begin{enumerate}
	  \item	constructor
	  \item	型変換
	  \item	オーバーロード
	  \item	\tt{to\_string}/\tt{print}関数
	\end{enumerate}
\end{narrow}

\subsubsection{is\_newable\_class()}
\begin{narrow}[15pt]
	constructorが\tt{private} or \tt{protected}なら\tt{new}不可\\
	\CLASS{Spr::IfInfo}も\tt{new}不可
\end{narrow}

\subsubsection{is\_virtual()}
\begin{narrow}[15pt]
	次のものは\tt{virtual}
	\begin{narrow}[\WID]\CLASS{
		UTAccessBase, UTTimerProvider,\\
		FWSceneFactory, FWSdkFactory,\\
		DRUpp,\\
		DVInputPort, DVOutputPort, DVOrientation,\\
		HISpidarCalcBase, HISpidarCalc3Dof, HISpidarCalc6Dof,\\
		CRSdkFactory
	}\end{narrow}
\end{narrow}
            
\subsubsection{generate\_constructor()}
\begin{narrow}[15pt]
	default constructorは必ず作る\\
	\tt{If}ならcast operatorを作る\\
	\tt{If}以外ならcopy constructor以外で定義されているconstructorを作る
\end{narrow}

\subsubsection{need\_generate\_constructor()}
\begin{narrow}[15pt]
	次のものはconstructorを作る
	\begin{narrow}[\WID]\CLASS{
		Vec2f, Vec2d, Vec3f, Vec3d, Vec4f, Vec4d,\\
		Quaternionf, Quaterniond,\\
		Posef, Posed,\\
		Matrix3f, Matrix3d,\\
		Vec2i, Vec3i, Vec6d,\\
		Curve3f
	}\end{narrow}
\end{narrow}

\subsubsection{generate\_constructor\_with\_full\_members()}
\begin{narrow}[15pt]
	全メンバを引数にもつconstructorを作る
\end{narrow}

\subsubsection{generate\_indexer()}
\begin{narrow}[15pt]
	\tt{[]}演算子処理の生成
\end{narrow}

\subsubsection{default\_operator\_func\_name()}
\begin{narrow}[15pt]
	\tt{.feature}の\tt{func\_name}に対応した関数名の作成
	\ (オーバーロード関数生成で使用)
\end{narrow}

\subsubsection{operator\_type\_analyzer()}
\begin{narrow}[15pt]
	\tt{.feature}の\tt{type}の解析 (オーバーロード関数生成で使用)
\end{narrow}

\subsubsection{generate\_operator()}
\begin{narrow}[15pt]
	\tt{.feature}の演算子処理関数の生成 (オーバーロード関数生成で使用)
\end{narrow}

\subsubsection{has\_print\_facility()}
\begin{narrow}[15pt]
	メンバに\FUNC{Print}, \FUNC{print}, \FUNC{operator}\verb|<<|\ を
	もつものは\FUNC{ToString()}生成可とする\\
	その他次のものも強制的に\FUNC{ToString()}を生成可とする
	\begin{narrow}
		\CLASS{Vec}, \CLASS{Quaternion}, \CLASS{Pose},
		\CLASS{Matrix}, \CLASS{Affine}で始まるクラス\\
		ただし\CLASS{MatrixExtension}は除く
	\end{narrow}
\end{narrow}

\subsubsection{generate\_to\_string()}
\begin{narrow}[15pt]
	\FUNC{ToString()}関数の生成
\end{narrow}

\subsubsection{generate\_enum\_def()}
\begin{narrow}[15pt]
	\tt{enum}定義の生成
\end{narrow}

\subsubsection{make\_wrapper\_type(),\\
	       make\_wrapper\_name(),\\
	       make\_wrapper\_name\_type\_part()}
\medskip
\begin{narrow}[15pt]
	wrapperクラス名を決める
\end{narrow}

\subsubsection{generate\_wrapper\_accessor()}
\begin{narrow}[15pt]
	wrapperクラスのアクセッサ生成の振分け
\end{narrow}

\subsubsection{is\_already\_generated()}
\begin{narrow}[15pt]
	\tt{accessor\_generation\_map}を用いて関数が生成済みかを判定
\end{narrow}

\subsubsection{generate\_accesor\_for\_type\_intrinsic\_pointer(),\\
	       generate\_accesor\_for\_type\_intrinsic\_bool(),\\
	       generate\_accesor\_for\_type\_intrinsics()}
\medskip
\begin{narrow}[15pt]
	基本型に対応するアクセッサを生成
\end{narrow}

\subsubsection{generate\_accesor\_for\_type\_string()}
\begin{narrow}[15pt]
	string型に対応するアクセッサを生成
\end{narrow}

\subsubsection{generate\_accesor\_for\_type\_struct\_enum(),\\
	       generate\_accesor\_for\_type\_struct\_pointer(),\\
	       generate\_accesor\_for\_type\_struct()}
\medskip
\begin{narrow}[15pt]
	struct型に対応するアクセッサを生成
\end{narrow}

\subsubsection{generate\_accesor\_for\_type\_enum()}
\begin{narrow}[15pt]
	enum型に対応するアクセッサを生成
\end{narrow}

\subsubsection{generate\_wrapper\_accessor\_struct()}
\begin{narrow}[15pt]
	wrapperクラスのアクセッサを生成 (vectorもarrayも扱う)
\end{narrow}

\subsubsection{generate\_accesor\_for\_type\_vector\_instrinsic(),\\
	       generate\_accesor\_for\_type\_vector\_struct(),\\
	       generate\_accesor\_for\_type\_vector\_string()}
\medskip
\begin{narrow}[15pt]
	vector型のアクセッサを生成 (vectorもarrayも扱う)
\end{narrow}

\subsubsection{generate\_accesor\_for\_type\_array\_instrinsic(),\\
	       generate\_accesor\_for\_type\_array\_struct(),\\
	       generate\_accesor\_for\_type\_array\_string()}
\medskip
\begin{narrow}[15pt]
	配列型のアクセッサを生成 (vectorもarrayも扱う)
\end{narrow}

\subsubsection{generate\_string\_get(),\\
	       generate\_string\_set()}
\medskip
\begin{narrow}[15pt]
	string型のアクセッサ生成のヘルパー
\end{narrow}

\subsubsection{get\_node\_info()}
\begin{narrow}[15pt]
	ノード情報の取得
\end{narrow}

\subsubsection{unqualified\_name()}
\begin{narrow}[15pt]
	\tt{Spr::}, \tt{std::}を取り除く\\
	\tt{forace==1}なら最後の\tt{:}以前を取り除く
\end{narrow}

\subsubsection{cs\_qualified\_name()}
\begin{narrow}[15pt]
	修飾名の中の\tt{::}を\tt{.}に置き換える
\end{narrow}

\subsubsection{set\_type\_info()}
\begin{narrow}[15pt]
	\tt{type}文字列を解析して
	\begin{narrow}{\tt
		uq\_type, cpp\_type, cs\_type,\\
		is\_typedef, is\_variable, is\_intrinsic, is\_struct, is\_string,\\
		cs\_marshaltype
	}\end{narrow}
	を設定する
\end{narrow}

\subsubsection{analyze\_vector()}
\begin{narrow}[15pt]
	\tt{type}または\tt{decl}の中の\tt{vector}\verb|<...>|\ を解析して
	型情報を取り出す
\end{narrow}

\subsubsection{analyze\_enum()}
\begin{narrow}[15pt]
	\tt{enum}の判定をする
\end{narrow}

\subsubsection{analyze\_syntax()}
\begin{narrow}[15pt]
	\tt{decl}または\tt{type}の解析のトップ
\end{narrow}

\subsubsection{analyze\_get\_id()}
\begin{narrow}[15pt]
	識別子部分の切り出し
\end{narrow}

\subsubsection{analyze\_function(),\\
	       analyze\_array()}
\medskip
\begin{narrow}[15pt]
	\tt{function}および\tt{array}の解析をする
\end{narrow}

\subsubsection{analyze\_qualifier()}
\begin{narrow}[15pt]
	\tt{q(const)}の解析をする
\end{narrow}

\subsubsection{analyze\_type\_modifier()}
\begin{narrow}[15pt]
	型修飾子の解析をする(\FUNC{analyze\_qualifier()}と一部重複する)
\end{narrow}

\subsubsection{strip\_type\_modifier(),\\
	       strip\_type\_modifier\_1()}
\medskip
\begin{narrow}[15pt]
	型修飾子を取り除く
\end{narrow}

\subsubsection{analyze\_type\_hook(),\\
	       analyze\_type\_hook\_1()}
\medskip
\begin{narrow}[15pt]
	\tt{typedef\_map}に登録されていたら型情報を置き換える
\end{narrow}

\subsubsection{analyze\_cs\_type\_hook(),\\
	       analyze\_cs\_type\_hook\_2()}
\medskip
\begin{narrow}[15pt]
	\tt{managed $\leftrightarrow$ unmanaged}間でやりとりする情報の
	型を調整する(\CS 側)
\end{narrow}

\subsubsection{analyze\_name\_hook()}
\begin{narrow}[15pt]
	名前の置換えをする
	\begin{itemize}
  	\item	\tt{checked}は\CS のreserved wordなので\tt{checked\_}とする
  	\item その他、\tt{SprCOLLADA::}, \tt{gimite::}などは取り除く
	\end{itemize}
\end{narrow}

\subsubsection{analyze\_skip()}
\begin{narrow}[15pt]
	次に文字\tt{.}が現れるまでスキップする
\end{narrow}

\subsubsection{analyze\_init\_funcargs(),\\
	       analyze\_count\_funcargs()}
\medskip
\begin{narrow}[15pt]
	関数引数解析のための初期処理
\end{narrow}

\subsubsection{overname()}
\begin{narrow}[15pt]
	オーバーロード関数の識別
\end{narrow}

\subsubsection{analyze\_cpp\_type\_repr()}
\begin{narrow}[15pt]
	\CPP の型表現の構成
\end{narrow}

\subsubsection{analyze\_error()}
\begin{narrow}[15pt]
	解析時のエラー処理
\end{narrow}

\subsubsection{get\_struct\_info(),\\
	       free\_struct\_info()}
\medskip
\begin{narrow}[15pt]
	\tt{StructInfo}の作成とメモリの解放
\end{narrow}

\subsubsection{string\_on\_heap()}
\begin{narrow}[15pt]
	heap上にメモリを確保する
\end{narrow}

\subsubsection{PRINTF()}
\begin{narrow}[15pt]
	\tt{flag}で指定されたファイルへの出力 (複数同時指定可)
\end{narrow}

\subsubsection{aort(),
	       snap\_at\_line(),\\
	       snap\_path\_info(),\\
	       dump\_node(),\\
	       dump\_node\_info(),\\
	       dump\_struct\_info(),\\
	       print\_nodes\_info(),\\
	       dump\_tree(),\\
	       debug\_break\_at()}
\medskip
\begin{narrow}[15pt]
	デバッグ用
\end{narrow}

% end: sprcs.tex
